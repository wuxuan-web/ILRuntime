/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
/*
 * extension.ts (and activateMockDebug.ts) forms the "plugin" that plugs into VS Code and contains the code that
 * connects VS Code with the debug adapter.
 * 
 * extension.ts contains code for launching the debug adapter in three different ways:
 * - as an external program communicating with VS Code via stdin/stdout,
 * - as a server process communicating with VS Code via sockets or named pipes, or
 * - as inlined code running in the extension itself (default).
 * 
 * Since the code in extension.ts uses node.js APIs it cannot run in the browser.
 */

'use strict';
import * as DGram from 'dgram';
import * as Net from 'net';
import * as vscode from 'vscode';
import { randomBytes } from 'crypto';
import { tmpdir } from 'os';
import { join } from 'path';
import { platform } from 'process';
import { ProviderResult } from 'vscode';
import { MockDebugSession } from './mockDebug';
import { activateMockDebug, workspaceFileAccessor } from './activateMockDebug';
import { BreakpointMapper } from './breakpointMapper';
import { HotReloadManager, HotReloadConfig } from './hotReloadManager';
import { DebugProtocolExtension } from './debugProtocolExtension';
import * as path from 'path';
import * as fs from 'fs';
import * as Path from 'path';
import * as Fs from 'fs';
// import { DebugSession } from '@vscode/debugadapter';

/*
 * The compile time flag 'runMode' controls how the debug adapter is run.
 * Please note: the test suite only supports 'external' mode.
 */
const runMode: 'external' | 'server' | 'namedPipeServer' | 'inline' = 'external';
let socket : DGram.Socket;
const maximumActiveTime : number  = 3000;
let activeServers :Map<string, ServerInfo> = new Map<string, ServerInfo>();

class BufferReader{
	private buffer: Buffer;
    private	offset: number = 0;

	constructor(buffer:Buffer){
		this.buffer = buffer;
	}

	readString():string{
		let len = this.buffer.readInt16LE(this.offset);
		this.offset= this.offset + 2;
		let res= this.buffer.toString(undefined, this.offset, this.offset+len);
		this.offset= this.offset + len;
		return res;
	}

	readInt():number{
		let res = this.buffer.readInt32LE(this.offset);
		this.offset = this.offset + 4;
		return res;
	}
}
export class ServerInfo{
	private address : string;
	private lastActive : number;
	private project : string;
	private machineName : string;
	private processId : number;
	private port : number;
	
	constructor(msg:Buffer, rInfo : DGram.RemoteInfo){
		let reader = new BufferReader(msg);
		this.project = reader.readString();
		this.machineName = reader.readString();
		this.processId = reader.readInt();
		this.port = reader.readInt();
		this.address = rInfo.address + ":" + this.port;
		this.lastActive = Date.now();
	}

	getAddress():string{
		return this.address;
	}

	getProject():string{
		return this.project;
	}

	getMachine():string{
		return this.machineName;
	}

	getProcessId():number{
		return this.processId;
	}

	isExipired():boolean{
		let pastTime = Date.now() - this.lastActive;
		return pastTime > maximumActiveTime;
	}
}

export function activate(context: vscode.ExtensionContext) {
	console.log('üöÄ ILRuntimeÊâ©Â±ïÊøÄÊ¥ª‰∏≠...');
	console.log(`üìÅ Â∑•‰ΩúÂå∫Ë∑ØÂæÑ: ${vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || 'Êú™ËÆæÁΩÆ'}`);
	
	let config = vscode.workspace.getConfiguration('ilruntime');
	console.log(`‚öôÔ∏è  ILRuntimeÈÖçÁΩÆ:`, JSON.stringify(config, null, 2));
	activeServers.clear();
	
	// Â∞ùËØïËøûÊé•Âà∞UnityÁöÑTCPË∞ÉËØïÊúçÂä°
	let port = config.get("broadcastPort") as number;
	console.log(`üîß Â∞ùËØïËøûÊé•Âà∞UnityË∞ÉËØïÊúçÂä°ÔºåÁ´ØÂè£: ${port}`);
	
	// ÂàõÂª∫TCPËøûÊé•
	const client = Net.createConnection(port, 'localhost', () => {
		console.log(`‚úÖ Â∑≤ËøûÊé•Âà∞UnityË∞ÉËØïÊúçÂä°: localhost:${port}`);
		
		// ÂàõÂª∫ÊúçÂä°Âô®‰ø°ÊÅØ
		let serverInfo = new ServerInfo(Buffer.from('Unity Debug Service'), { 
			address: 'localhost', 
			port: port,
			family: 'IPv4',
			size: 0
		});
		activeServers.set(serverInfo.getAddress(), serverInfo);
		console.log(`‚úÖ ÊúçÂä°Âô®‰ø°ÊÅØÂ∑≤Ê∑ªÂä†: ${serverInfo.getAddress()}`);
		console.log(`üìä ÂΩìÂâçÊ¥ªË∑ÉÊúçÂä°Âô®Êï∞Èáè: ${activeServers.size}`);
	});
	
	client.on('error', (err) => {
		console.error('‚ùå ËøûÊé•UnityË∞ÉËØïÊúçÂä°Â§±Ë¥•:', err.message);
		console.log('üí° ËØ∑Á°Æ‰øùUnityÈ°πÁõÆÊ≠£Âú®ËøêË°åÔºåÂπ∂‰∏îË∞ÉËØïÊúçÂä°Â∑≤ÂêØÂä®');
	});
	
	client.on('close', () => {
		console.log('üîå ‰∏éUnityË∞ÉËØïÊúçÂä°ÁöÑËøûÊé•Â∑≤ÂÖ≥Èó≠');
	});
	
	// ‰øùÊåÅUDPÁõëÂê¨‰Ωú‰∏∫Â§áÁî®
	socket = DGram.createSocket("udp4");
	
	socket.on("message", function (msg, rinfo) {
		console.log(`üì° Êî∂Âà∞UDPÊ∂àÊÅØ: ${rinfo.address}:${rinfo.port}`);
		let serverInfo = new ServerInfo(msg, rinfo);
		activeServers.set(serverInfo.getAddress(), serverInfo);
		console.log(`‚úÖ ÊúçÂä°Âô®‰ø°ÊÅØÂ∑≤Ê∑ªÂä†: ${serverInfo.getAddress()}`);
	});
	
	socket.on("error", function (err) {
		console.error('‚ùå UDPÁõëÂê¨ÈîôËØØ:', err);
	});
	
	socket.on("listening", function () {
		const address = socket.address();
		console.log(`üéØ UDPÁõëÂê¨Â∑≤ÂêØÂä®: ${address.address}:${address.port}`);
	});
	
	socket.bind(port);

	// ÂàùÂßãÂåñÁÉ≠Êõ¥Êñ∞ÂäüËÉΩ
	initializeHotReload(context);
	
    // debug adapters can be run in different ways by using a vscode.DebugAdapterDescriptorFactory:
	switch (runMode) {
		case 'server':
			// run the debug adapter as a server inside the extension and communicate via a socket
			activateMockDebug(context, activeServers, new MockDebugAdapterServerDescriptorFactory());
			break;

		case 'namedPipeServer':
			// run the debug adapter as a server inside the extension and communicate via a named pipe (Windows) or UNIX domain socket (non-Windows)
			activateMockDebug(context, activeServers, new MockDebugAdapterNamedPipeServerDescriptorFactory());
			break;

		case 'external': default:
			// run the debug adapter as a separate process
			activateMockDebug(context, activeServers, new DebugAdapterExecutableFactory());
			break;

		case 'inline':
			// run the debug adapter inside the extension and directly talk to it
			activateMockDebug(context, activeServers);
			break;
	}
}

// ÁÉ≠Êõ¥Êñ∞ÁÆ°ÁêÜÂô®ÂÆû‰æã
let hotReloadManager: HotReloadManager | undefined;
let breakpointMapper: BreakpointMapper | undefined;
let debugProtocolExtension: DebugProtocolExtension | undefined;

/**
 * Êü•ÊâæÁÉ≠Êõ¥Êñ∞Á®ãÂ∫èÈõÜ
 */
function findHotfixAssembly(workspacePath: string): string {
	// Â∏∏ËßÅÁöÑILRuntime DemoÈ°πÁõÆÁªìÊûÑ
	const possiblePaths = [
		path.join(workspacePath, 'HotfixAOT', 'bin', 'Debug', 'net9.0', 'HotfixAOT.dll'),
		path.join(workspacePath, 'HotfixAOT', 'bin', 'Release', 'net9.0', 'HotfixAOT.dll'),
		path.join(workspacePath, 'Hotfix', 'bin', 'Debug', 'net9.0', 'Hotfix.dll'),
		path.join(workspacePath, 'Hotfix', 'bin', 'Release', 'net9.0', 'Hotfix.dll'),
		path.join(workspacePath, 'Assets', 'StreamingAssets', 'HotfixAOT.dll'),
		path.join(workspacePath, 'Assets', 'StreamingAssets', 'Hotfix.dll')
	];
	
	for (const dllPath of possiblePaths) {
		if (fs.existsSync(dllPath)) {
			return dllPath;
		}
	}
	
	// Â¶ÇÊûúÊâæ‰∏çÂà∞ÔºåËøîÂõûÈªòËÆ§Ë∑ØÂæÑ
	return path.join(workspacePath, 'HotfixAOT', 'bin', 'Debug', 'net9.0', 'HotfixAOT.dll');
}

/**
 * ÂàùÂßãÂåñÁÉ≠Êõ¥Êñ∞ÂäüËÉΩ
 */
function initializeHotReload(context: vscode.ExtensionContext): void {
	try {
		// Ëé∑ÂèñÂ∑•‰ΩúÂå∫Ë∑ØÂæÑ
		const workspacePath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '';
		
		// ÂàõÂª∫Êñ≠ÁÇπÊò†Â∞ÑÂô®
		breakpointMapper = new BreakpointMapper(workspacePath);
		
		// ÂàõÂª∫ÁÉ≠Êõ¥Êñ∞ÈÖçÁΩÆ
		const hotReloadConfig: HotReloadConfig = {
			dllPath: workspacePath, // Â∑•‰ΩúÂå∫Ë∑ØÂæÑ
			patchPath: path.join(workspacePath, 'Patches'), // Ë°•‰∏ÅÊñá‰ª∂Ë∑ØÂæÑ
			autoReload: true,
			watchPattern: '**/*.cs',
			sourceAssembly: findHotfixAssembly(workspacePath), // Ëá™Âä®Êü•ÊâæÁÉ≠Êõ¥Êñ∞Á®ãÂ∫èÈõÜ
			targetAssembly: findHotfixAssembly(workspacePath) // Ëá™Âä®Êü•ÊâæÁÉ≠Êõ¥Êñ∞Á®ãÂ∫èÈõÜ
		};
		
		// ÂàõÂª∫ÁÉ≠Êõ¥Êñ∞ÁÆ°ÁêÜÂô®
		hotReloadManager = new HotReloadManager(breakpointMapper, hotReloadConfig);
		
		// ÂàõÂª∫Ë∞ÉËØïÂçèËÆÆÊâ©Â±ï
		debugProtocolExtension = new DebugProtocolExtension(breakpointMapper, hotReloadManager);
		
		// Ê≥®ÂÜåÁÉ≠Êõ¥Êñ∞‰∫ã‰ª∂Â§ÑÁêÜ
		hotReloadManager.onEvent((event) => {
			console.log('Hot reload event:', event);
			
			// ÊòæÁ§∫ÈÄöÁü•
			switch (event.type) {
				case 'started':
					vscode.window.showInformationMessage(`ÁÉ≠Êõ¥Êñ∞ÂºÄÂßã: ${event.message}`);
					break;
				case 'completed':
					vscode.window.showInformationMessage(`ÁÉ≠Êõ¥Êñ∞ÂÆåÊàê: ${event.message}`);
					break;
				case 'failed':
					vscode.window.showErrorMessage(`ÁÉ≠Êõ¥Êñ∞Â§±Ë¥•: ${event.error}`);
					break;
				case 'breakpoints-updated':
					vscode.window.showInformationMessage(`Êñ≠ÁÇπÂ∑≤Êõ¥Êñ∞: ${event.message}`);
					break;
			}
		});
		
		// Ê≥®ÂÜåÂëΩ‰ª§
		context.subscriptions.push(
			vscode.commands.registerCommand('extension.ilruntime-debug.hotReloadStatus', () => {
				if (hotReloadManager) {
					const status = hotReloadManager.getStatus();
					const config = hotReloadManager.getConfig();
					vscode.window.showInformationMessage(
						`ÁÉ≠Êõ¥Êñ∞Áä∂ÊÄÅ: ${status}\nÈÖçÁΩÆ: ${JSON.stringify(config, null, 2)}`
					);
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.manualHotReload', async () => {
				if (hotReloadManager) {
					try {
						await hotReloadManager.manualHotReload();
						vscode.window.showInformationMessage('ÊâãÂä®ÁÉ≠Êõ¥Êñ∞ÂÆåÊàê');
					} catch (error) {
						vscode.window.showErrorMessage(`ÊâãÂä®ÁÉ≠Êõ¥Êñ∞Â§±Ë¥•: ${error}`);
					}
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.syncBreakpoints', async () => {
				if (breakpointMapper && hotReloadManager) {
					try {
						await hotReloadManager.manualHotReload();
						vscode.window.showInformationMessage('Êñ≠ÁÇπÂêåÊ≠•ÂÆåÊàê');
					} catch (error) {
						vscode.window.showErrorMessage(`Êñ≠ÁÇπÂêåÊ≠•Â§±Ë¥•: ${error}`);
					}
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.exportBreakpoints', async () => {
				if (breakpointMapper) {
					try {
						const uri = await vscode.window.showSaveDialog({
							filters: { 'JSON Files': ['json'] }
						});
						
						if (uri) {
							const success = await breakpointMapper.exportBreakpoints(uri.fsPath);
							if (success) {
								vscode.window.showInformationMessage('Êñ≠ÁÇπÈÖçÁΩÆÂØºÂá∫ÊàêÂäü');
							} else {
								vscode.window.showErrorMessage('Êñ≠ÁÇπÈÖçÁΩÆÂØºÂá∫Â§±Ë¥•');
							}
						}
					} catch (error) {
						vscode.window.showErrorMessage(`ÂØºÂá∫Â§±Ë¥•: ${error}`);
					}
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.importBreakpoints', async () => {
				if (breakpointMapper) {
					try {
						const uris = await vscode.window.showOpenDialog({
							filters: { 'JSON Files': ['json'] },
							canSelectMany: false
						});
						
						if (uris && uris.length > 0) {
							const success = await breakpointMapper.importBreakpoints(uris[0].fsPath);
							if (success) {
								vscode.window.showInformationMessage('Êñ≠ÁÇπÈÖçÁΩÆÂØºÂÖ•ÊàêÂäü');
							} else {
								vscode.window.showErrorMessage('Êñ≠ÁÇπÈÖçÁΩÆÂØºÂÖ•Â§±Ë¥•');
							}
						}
					} catch (error) {
						vscode.window.showErrorMessage(`ÂØºÂÖ•Â§±Ë¥•: ${error}`);
					}
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.backupBreakpoints', async () => {
				if (breakpointMapper) {
					try {
						const backupPath = await breakpointMapper.backupBreakpoints();
						if (backupPath) {
							vscode.window.showInformationMessage(`Êñ≠ÁÇπÈÖçÁΩÆÂ∑≤Â§á‰ªΩÂà∞: ${backupPath}`);
						} else {
							vscode.window.showErrorMessage('Êñ≠ÁÇπÈÖçÁΩÆÂ§á‰ªΩÂ§±Ë¥•');
						}
					} catch (error) {
						vscode.window.showErrorMessage(`Â§á‰ªΩÂ§±Ë¥•: ${error}`);
					}
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.showBreakpointInfo', async () => {
				if (breakpointMapper) {
					try {
						const configInfo = await breakpointMapper.getConfigInfo();
						const message = configInfo.exists 
							? `Êñ≠ÁÇπÈÖçÁΩÆÊñá‰ª∂: ${configInfo.path}\nÊñ≠ÁÇπÊï∞Èáè: ${configInfo.breakpointCount}\nÊúÄÂêé‰øÆÊîπ: ${new Date(configInfo.lastModified || 0).toLocaleString()}`
							: 'Êú™ÊâæÂà∞Êñ≠ÁÇπÈÖçÁΩÆÊñá‰ª∂';
						vscode.window.showInformationMessage(message);
					} catch (error) {
						vscode.window.showErrorMessage(`Ëé∑ÂèñÈÖçÁΩÆ‰ø°ÊÅØÂ§±Ë¥•: ${error}`);
					}
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.showILRuntimeStatus', async () => {
				if (hotReloadManager) {
					try {
						const ilruntimeStatus = await hotReloadManager.getILRuntimeStatus();
						const patchToolStatus = await hotReloadManager.getPatchToolStatus();
						
						let message = 'ILRuntimeÈõÜÊàêÁä∂ÊÄÅ:\n';
						message += `ILRuntime: ${ilruntimeStatus.available ? 'ÂèØÁî®' : '‰∏çÂèØÁî®'}\n`;
						if (ilruntimeStatus.path) message += `Ë∑ØÂæÑ: ${ilruntimeStatus.path}\n`;
						message += `Ë°•‰∏ÅÂ∑•ÂÖ∑: ${patchToolStatus.available ? 'ÂèØÁî®' : '‰∏çÂèØÁî®'}\n`;
						if (patchToolStatus.path) message += `Ë∑ØÂæÑ: ${patchToolStatus.path}`;
						
						vscode.window.showInformationMessage(message);
					} catch (error) {
						vscode.window.showErrorMessage(`Ëé∑ÂèñILRuntimeÁä∂ÊÄÅÂ§±Ë¥•: ${error}`);
					}
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.showPatchHistory', async () => {
				if (hotReloadManager) {
					try {
						const history = await hotReloadManager.getPatchHistory();
						if (history.length === 0) {
							vscode.window.showInformationMessage('Ê≤°ÊúâË°•‰∏ÅÂéÜÂè≤ËÆ∞ÂΩï');
						} else {
							const message = `Ë°•‰∏ÅÂéÜÂè≤ (ÂÖ±${history.length}‰∏™):\n` + 
								history.slice(0, 5).map(patch => 
									`- ${new Date(patch.timestamp).toLocaleString()}: ${patch.types.length}‰∏™Á±ªÂûã`
								).join('\n');
							vscode.window.showInformationMessage(message);
						}
					} catch (error) {
						vscode.window.showErrorMessage(`Ëé∑ÂèñË°•‰∏ÅÂéÜÂè≤Â§±Ë¥•: ${error}`);
					}
				}
			}),
			
			vscode.commands.registerCommand('extension.ilruntime-debug.cleanupPatches', async () => {
				if (hotReloadManager) {
					try {
						await hotReloadManager.cleanupPatchFiles(7);
						vscode.window.showInformationMessage('Â∑≤Ê∏ÖÁêÜ7Â§©ÂâçÁöÑË°•‰∏ÅÊñá‰ª∂');
					} catch (error) {
						vscode.window.showErrorMessage(`Ê∏ÖÁêÜË°•‰∏ÅÊñá‰ª∂Â§±Ë¥•: ${error}`);
					}
				}
			})
		);
		
		console.log('Hot reload functionality initialized successfully');
		
	} catch (error) {
		console.error('Failed to initialize hot reload functionality:', error);
		vscode.window.showErrorMessage(`ÁÉ≠Êõ¥Êñ∞ÂäüËÉΩÂàùÂßãÂåñÂ§±Ë¥•: ${error}`);
	}
}

export function deactivate() {
	// Ê∏ÖÁêÜÁÉ≠Êõ¥Êñ∞ËµÑÊ∫ê
	if (hotReloadManager) {
		hotReloadManager.dispose();
		hotReloadManager = undefined;
	}
	
	if (breakpointMapper) {
		breakpointMapper.dispose();
		breakpointMapper = undefined;
	}
	
	if (debugProtocolExtension) {
		debugProtocolExtension.dispose();
		debugProtocolExtension = undefined;
	}
	
	// Ê∏ÖÁêÜÂéüÊúâËµÑÊ∫ê
	if(socket !== null){
		socket.close();
	}
	activeServers.clear();	
}
export let currentSession : vscode.DebugSession;
class DebugAdapterExecutableFactory implements vscode.DebugAdapterDescriptorFactory {

	createDebugAdapterDescriptor(_session: vscode.DebugSession, executable: vscode.DebugAdapterExecutable | undefined): ProviderResult<vscode.DebugAdapterDescriptor> {
		console.log('üîß ÂàõÂª∫ILRuntimeË∞ÉËØïÈÄÇÈÖçÂô®ÊèèËø∞Á¨¶...');
		console.log(`üìã ‰ºöËØùÈÖçÁΩÆ:`, JSON.stringify(_session.configuration, null, 2));
		console.log(`üìã ‰ºöËØùÁ±ªÂûã: ${_session.type}`);
		console.log(`üìã ‰ºöËØùÂêçÁß∞: ${_session.name}`);
		
		currentSession = _session;
		
		// Ëé∑ÂèñILRuntimeÈÖçÁΩÆ
		let config = vscode.workspace.getConfiguration('ilruntime');
		let program = config.get("debugAdapterPath") as string;
		console.log(`üîç ÈÖçÁΩÆÁöÑË∞ÉËØïÈÄÇÈÖçÂô®Ë∑ØÂæÑ: ${program}`);
		console.log(`üìÅ ÂΩìÂâçÁõÆÂΩï: ${process.cwd()}`);
		console.log(`üìÅ __dirname: ${__dirname}`);
		console.log(`üìÅ Êâ©Â±ïÊ†πÁõÆÂΩï: ${Path.dirname(__dirname)}`);
		
		// Â¶ÇÊûúÈÖçÁΩÆ‰∏≠Ê≤°ÊúâË∑ØÂæÑÔºåÂ∞ùËØïËá™Âä®Êü•Êâæ
		if (!program) {
			console.log('üîç ÈÖçÁΩÆ‰∏≠Êú™ÊåáÂÆöË∑ØÂæÑÔºåÂ∞ùËØïËá™Âä®Êü•Êâæ...');
			
					// Ëé∑ÂèñÊâ©Â±ïÊ†πÁõÆÂΩï - Â∞ùËØïÂ§öÁßçÊñπÂºè
		let extensionRoot = '';
		const possibleRoots = [
			Path.dirname(__dirname), // ‰ªédistÁõÆÂΩïÂêë‰∏ä
			Path.dirname(Path.dirname(__dirname)), // ‰ªédistÁõÆÂΩïÂêë‰∏ä‰∏§Á∫ß
			Path.resolve(__dirname, '../..'), // Áõ∏ÂØπË∑ØÂæÑ
			Path.resolve(process.cwd(), '../VSCodeDAILRuntime').replace('/VSCodeDAILRuntime', '') // ‰ªéÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩï
		];
		
		for (const root of possibleRoots) {
			const testPath = Path.join(root, 'VSCodeDAILRuntime', 'bin', 'Debug', 'net9.0', 'osx-arm64', 'VSCodeDAILRuntime');
			if (Fs.existsSync(testPath)) {
				extensionRoot = root;
				console.log(`‚úÖ ÊâæÂà∞Êâ©Â±ïÊ†πÁõÆÂΩï: ${extensionRoot}`);
				break;
			}
		}
		
		if (!extensionRoot) {
			console.log('‚ö†Ô∏è  Êó†Ê≥ïÁ°ÆÂÆöÊâ©Â±ïÊ†πÁõÆÂΩïÔºå‰ΩøÁî®Â§áÁî®ÊñπÊ°à');
			extensionRoot = Path.dirname(__dirname);
		}
		
		console.log(`üìÅ Êâ©Â±ïÊ†πÁõÆÂΩï: ${extensionRoot}`);
		
		const possiblePaths = [
			// ‰ªéÊâ©Â±ïÊ†πÁõÆÂΩï
			Path.join(extensionRoot, 'VSCodeDAILRuntime', 'bin', 'Debug', 'net9.0', 'osx-arm64', 'VSCodeDAILRuntime'),
			Path.join(extensionRoot, 'VSCodeDAILRuntime', 'bin', 'Debug', 'net6.0', 'osx-arm64', 'VSCodeDAILRuntime'),
			Path.join(extensionRoot, 'VSCodeDAILRuntime', 'bin', 'Release', 'net9.0', 'osx-arm64', 'VSCodeDAILRuntime'),
			Path.join(extensionRoot, 'VSCodeDAILRuntime', 'bin', 'Release', 'net6.0', 'osx-arm64', 'VSCodeDAILRuntime'),
			// ‰ªéÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩï
			Path.resolve(process.cwd(), '../VSCodeDAILRuntime/bin/Debug/net9.0/osx-arm64/VSCodeDAILRuntime'),
			Path.resolve(process.cwd(), '../VSCodeDAILRuntime/bin/Debug/net6.0/osx-arm64/VSCodeDAILRuntime'),
			// ‰ªé__dirname
			Path.resolve(__dirname, '../VSCodeDAILRuntime/bin/Debug/net9.0/osx-arm64/VSCodeDAILRuntime'),
			Path.resolve(__dirname, '../VSCodeDAILRuntime/bin/Debug/net6.0/osx-arm64/VSCodeDAILRuntime'),
			// ÁªùÂØπË∑ØÂæÑ
			'/Users/newuser/Project/ILRuntime/Debugging/VSCode/VSCodeDAILRuntime/bin/Debug/net9.0/osx-arm64/VSCodeDAILRuntime'
		];
			
			for (const fullPath of possiblePaths) {
				console.log(`üîç Ê£ÄÊü•Ë∑ØÂæÑ: ${fullPath}`);
				if (Fs.existsSync(fullPath)) {
					console.log(`‚úÖ ÊâæÂà∞Ë∞ÉËØïÈÄÇÈÖçÂô®: ${fullPath}`);
					program = fullPath;
					break;
				}
			}
		}
		
		if (!program) {
			console.error('‚ùå Êú™ÊâæÂà∞Ë∞ÉËØïÈÄÇÈÖçÂô®Á®ãÂ∫è');
			throw new Error('Êú™ÊâæÂà∞Ë∞ÉËØïÈÄÇÈÖçÂô®Á®ãÂ∫èÔºåËØ∑Ê£ÄÊü•ÈÖçÁΩÆÊàñÁ°Æ‰øùÂ∑≤ÁºñËØëVSCodeDAILRuntime');
		}
		
		// Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
		if (!Fs.existsSync(program)) {
			console.error(`‚ùå Ë∞ÉËØïÈÄÇÈÖçÂô®Êñá‰ª∂‰∏çÂ≠òÂú®: ${program}`);
			throw new Error(`Ë∞ÉËØïÈÄÇÈÖçÂô®Êñá‰ª∂‰∏çÂ≠òÂú®: ${program}`);
		}
		
		console.log(`‚úÖ Ë∞ÉËØïÈÄÇÈÖçÂô®Êñá‰ª∂Â≠òÂú®: ${program}`);
		console.log(`üìä Êñá‰ª∂Â§ßÂ∞è: ${Fs.statSync(program).size} Â≠óËäÇ`);
		console.log(`üìä Êñá‰ª∂ÊùÉÈôê: ${Fs.statSync(program).mode.toString(8)}`);
		
		// Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶ÂèØÊâßË°å
		try {
			Fs.accessSync(program, Fs.constants.X_OK);
			console.log('‚úÖ Êñá‰ª∂ÂÖ∑ÊúâÊâßË°åÊùÉÈôê');
		} catch (error) {
			console.warn('‚ö†Ô∏è  Êñá‰ª∂Ê≤°ÊúâÊâßË°åÊùÉÈôêÔºåÂ∞ùËØïÊ∑ªÂä†...');
			try {
				Fs.chmodSync(program, 0o755);
				console.log('‚úÖ Â∑≤Ê∑ªÂä†ÊâßË°åÊùÉÈôê');
			} catch (chmodError) {
				console.error('‚ùå Êó†Ê≥ïÊ∑ªÂä†ÊâßË°åÊùÉÈôê:', chmodError);
			}
		}
		
		// ÂàõÂª∫Ë∞ÉËØïÈÄÇÈÖçÂô®ÂèØÊâßË°åÊñá‰ª∂
		const args: string[] = [];
		const options = {
			cwd: Path.dirname(program),
			env: { 
				...process.env,
				"ILRUNTIME_DEBUG": "1"
			}
		};
		
		console.log(`üöÄ ÂêØÂä®Ë∞ÉËØïÈÄÇÈÖçÂô®: ${program}`);
		console.log(`üìÅ Â∑•‰ΩúÁõÆÂΩï: ${options.cwd}`);
		console.log(`üîß ÂèÇÊï∞: ${args.join(' ')}`);
		
		executable = new vscode.DebugAdapterExecutable(program, args, options);
		
		// make VS Code launch the DA executable
		return executable;
	}
}

class MockDebugAdapterServerDescriptorFactory implements vscode.DebugAdapterDescriptorFactory {

	private server?: Net.Server;

	createDebugAdapterDescriptor(session: vscode.DebugSession, executable: vscode.DebugAdapterExecutable | undefined): vscode.ProviderResult<vscode.DebugAdapterDescriptor> {

		if (!this.server) {
			// start listening on a random port
			this.server = Net.createServer(socket => {
				const session = new MockDebugSession(workspaceFileAccessor);
				session.setRunAsServer(true);
				session.start(socket as NodeJS.ReadableStream, socket);
			}).listen(0);
		}

		// make VS Code connect to debug server
		return new vscode.DebugAdapterServer((this.server.address() as Net.AddressInfo).port);
	}

	dispose() {
		if (this.server) {
			this.server.close();
		}
	}
}

class MockDebugAdapterNamedPipeServerDescriptorFactory implements vscode.DebugAdapterDescriptorFactory {

	private server?: Net.Server;

	createDebugAdapterDescriptor(session: vscode.DebugSession, executable: vscode.DebugAdapterExecutable | undefined): vscode.ProviderResult<vscode.DebugAdapterDescriptor> {

		if (!this.server) {
			// start listening on a random named pipe path
			const pipeName = randomBytes(10).toString('utf8');
			const pipePath = platform === "win32" ? join('\\\\.\\pipe\\', pipeName) : join(tmpdir(), pipeName);

			this.server = Net.createServer(socket => {
				const session = new MockDebugSession(workspaceFileAccessor);
				session.setRunAsServer(true);
				session.start(<NodeJS.ReadableStream>socket, socket);
			}).listen(pipePath);
		}

		// make VS Code connect to debug server
		return new vscode.DebugAdapterNamedPipeServer(this.server.address() as string);
	}

	dispose() {
		if (this.server) {
			this.server.close();
		}
	}
}
